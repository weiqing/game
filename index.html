<!doctype html>
<html>
	<head>
    		<script src="phaser.min.js"></script>
    		<style>
    			body{margin:0}
    		</style>
    		<script type="text/javascript">
			window.onload = function() {
                    // tile width, in pixels
				var tileSize = 100;
				var colMax = 5;
				var rowMax = 5;
				var gameInfo;
				
				// creation of a new phaser game, with a proper width and height according to tile size
				var game = new Phaser.Game(tileSize*(colMax+2),tileSize*(rowMax+5),Phaser.CANVAS,"",{preload:onPreload, create:onCreate, update:onUpdate});
				// game array, starts with all cells to zero
				var fieldArray = Array(colMax * rowMax).fill(0);
				// this is the group which will contain all tile sprites
				var tileSprites;
				var frontGroup;
				var tileMap = {};
				var scoreTile;
				var lifeTile;
				var foundBlocksCancelDedupe = false;
				
				// variables to handle keyboard input
				var upKey;
				var downKey;
				var leftKey;
				var rightKey;
				// colors to tint tiles according to their value

				var colors = {
					0:0x71FF61,
					1:0xBAF058,
					2:0x5BC2FA,
					3:0xFEC764,
					4:0xFD725D,
					5:0x179D87,
					6:0x7768F7,
					7:0xF45CC2,
					8:0xFFBBBB,
					9:0xFFAAAA
				}
				
				var textColors = {
					1:"3FAC21",
					2:"208BFA",
					3:"FC732F",
					4:"F5D19A",
					5:"83E59F",
					6:"CDBDFD",
					7:"FCBEA2"
				}
				
				// create a new bitmap data object
			    var bmd;
				
				for (var i = 10; i<999; i++) {
					colors[i] = Math.random()*0xFFFFFF<<0;
				}
				// at the beginning of the game, the player cannot move
                    var canMove=false;
					var lock = 0;
					
				// THE GAME IS PRELOADING
				function onPreload() {
					// preload the only image we are using in the game
					// game.load.image("tile", "tile.png");
					bmd = game.add.bitmapData(tileSize,tileSize);

				    // draw to the canvas context like normal
				    bmd.ctx.beginPath();
				    bmd.ctx.rect(0,0,tileSize,tileSize);
				    bmd.ctx.fillStyle = '#fefefe';
				    bmd.ctx.fill();

					background = game.add.image(0, 0, bmd);
        			background.height = game.height;
        			background.width = game.width;
				}
				
				// THE GAME HAS BEEN CREATED
				function onCreate() {
					
					gameInfo = {"score":0, "life":5};

					// sprite group declaration
					tileSprites = game.add.group();
					frontGroup = game.add.group();
					
					verticalMargin = (game.height - (tileSize * rowMax))/2;
					horizontalMargin = (game.width - (tileSize * colMax))/2;
					
					tileSprites.x = horizontalMargin;
					tileSprites.y = verticalMargin;
					
					frontGroup.x = horizontalMargin;
					frontGroup.y = verticalMargin;

					scoreTile = game.add.text(160, 100, "score: 0");
					scoreTile.anchor.set(0.5);
					
					lifeTile = game.add.text(150, 200, "life: 5");
					lifeTile.anchor.set(0.5);

					initGame();
				}
				
				function onUpdate() {
					// console.log("update");
					if (canMove && lock == 0) {
						fall();
						// check();
					}
					if (!containsZero() && lock == 0) {
						// console.log("done");
						check();
					}
					
					lifeTile.setText("life: " + gameInfo["life"].toString());
					scoreTile.setText("score: " + gameInfo["score"].toString());
					// if (lock == 0) {
					// 	check();
					// }
				}
				
				function containsZero() {
					for (var j=colMax - 1; j>=0; j--) {
						for (var i=rowMax - 1; i>=0; i--) {
							if (fieldArray[i*colMax + j] == 0) return true;
						}
					}
					return false;
				}
				
				function findRandomBlocksToCancel() {
					var result = [];
					for (var j=colMax - 1; j>=0; j--) {
						for (var i=0; i<rowMax; i++) {
							var visited = Array(colMax * rowMax).fill(0);
							var val = findBlocks(i, j, visited);
							if ( val >= 3) {
								result.push(i*colMax + j);
							}
						}
					}
					if (result.length == 0) {
						return null;
					} else {
						var pos = result.sort(function (a, b) {  return a - b;})[0];
						// console.log(result);
						// console.log("cancel " + toRow(pos) + " " + toCol(pos));
						return pos;
					}
				}
				
				function check() {
					// console.log(canMove);
					if (containsZero() || lock != 0 || !canMove) {
						return;
					}
					var pos = findRandomBlocksToCancel();
					
					if (pos != null) {
						var x = toRow(pos);
						var y = toCol(pos);
						canMove = false;
						if (foundBlocksCancelDedupe == true) {
							return;
						}

						foundBlocksCancelDedupe = true;
						setTimeout(function(){  
							
								// console.log("timeout func: ", x, y);
								// 
								shrinkBlocksPostClick(x, y, function() {
									foundBlocksCancelDedupe = false;
								});
							
						}, 300);
					}
				}
				
				function fall() {
					for (var i=0; i<rowMax; i++) {
						for (var j=0; j<colMax; j++) {
							if (i == 0 && fieldArray[i*colMax + j] == 0) {
								var randomValue = Math.floor(Math.random()*4) + 1;
								// console.log("createing tile");
								createTile(i, j, randomValue);
								fieldArray[i*colMax + j] = randomValue;
								updateNumbers();
							}
							if (i + 1 < rowMax && 
								fieldArray[(i+1)*colMax + j] == 0 &&
							    fieldArray[i*colMax + j] != 0) {
								// console.log(canMove, i, j);
								// canMove = false;
								tileSprites.forEach(function(item){
									var endPos = (i+1)*colMax + j;
									if(item.pos == i*colMax + j) {
										// console.log(i ,j, item.pos, endPos);
										lock += 1;
										moveTileWithSteps(item, [item.pos, endPos], function(currentTile){
					
											fieldArray[endPos] = fieldArray[currentTile.pos];
											fieldArray[currentTile.pos] = 0;
											// console.log(currentTile.pos, endPos);
											currentTile.pos = endPos;
											
											// canMove = true;
											lock -= 1;
											printBoard();
										});
									}
								});
							}
						}
					}
				}
				
				function initGame() {
					// var debug = [1, 1, 3, 4, 1, 2, 2, 2, 3, 5, 4, 5, 2, 3, 4, 5];
					
					for (var i=0; i<rowMax; i++) {
						for (var j=0; j<colMax; j++) {
							var pos = i*colMax + j;
							var visited = Array(colMax * rowMax).fill(0);
							do{
								// console.log(i, j);
								visited = Array(colMax * rowMax).fill(0);
								var randomValue = Math.floor(Math.random()*5) + 1;
								fieldArray[pos] = randomValue;
								// checkBoard();
								// console.log(findBlocks(i, j, randomValue, visited) > 2);
							} while (findBlocks(i, j, visited) > 2)
							// fieldArray[pos] = debug[pos];
							createTile(i, j, fieldArray[pos]);
							
						}
					}
					// console.log(fieldArray);
					
					game.scale.scaleMode = Phaser.ScaleManager.aspectRatio;
					game.scale.pageAlignVertically = true;
					game.scale.pageAlignHorizontally = true;
					game.scale.setShowAll();
					game.scale.refresh();
					// creation of a new sprite with "tile" instance, that is "tile.png" we loaded before
					
				}
				
				function click(i, j) {
					if (canMove == true && lock == 0) {
						gameInfo["life"] -= 1;
						fieldArray[i*colMax+j] += 1;
						updateNumbers();
						// checkBoard();
						// cancelConnections(i, j);
						
						shrinkBlocksPostClick(i, j);
					}
				}
				
				function shrinkBlocksPostClick(i, j, callback) {
					// console.log(i, j);
					if (findBlocks(i, j, Array(colMax * rowMax).fill(0)) >= 3) {
						canMove = false;
						var targetVal = fieldArray[i*colMax + j];
						var visited = Array(colMax * rowMax).fill(0);
						var result = {};
						findConnectingBlocks(i, j, targetVal, visited, result, []);
						var maxLength = 0;
						var maxPos = i * colMax + j;
						for (var pos in result){
							if (maxLength < result[pos].length) {
								maxLength = result[pos].length;
								maxPos = pos;
							}
							if (pos != i*colMax + j) {
								fieldArray[pos] = 0;
							}
						}
						// console.log(result);
						for (var pos in result){
							// if (pos == i*colMax + j) {
							// 	continue;
							// }
							var path = result[pos].reverse();
							tileSprites.forEach(function(item){
								if(item.pos == pos) {
									// console.log(i ,j, item.pos);
									
									moveTileWithSteps(item, path, function(currentTile){
										item.destroy();
										if (maxPos == currentTile.pos) {
											// console.log("last one");
											if (callback) {
												callback();
											}
											fieldArray[i*colMax + j] += 1;
											canMove = true;
											updateNumbers();
											
											if (gameInfo["life"] <= 4) {
												gameInfo["life"] += 1;
											}
											// checkBoard();
											// printBoard();
										}
									}, function(currentTile){
										var style = { font: "bold 30px Arial", fill: "#aaaaaa", align: "center" };
										var score = parseInt(currentTile.children[0]._text) * 10;
										var text = game.add.text(currentTile.x + tileSize/2, currentTile.y + tileSize/2, score.toString(), style);
										text.visible = false;
										text.anchor.set(0.5);
										frontGroup.add(text);
										var textMovement = game.add.tween(text);
										var textScale = game.add.tween(text.scale);
										
										// textMovement = textMovement.to({alpha:1},250,Phaser.Easing.Linear.None, true, 1000*(maxLength-path.length));
										textMovement = textMovement.to({alpha:0.5, x:text.x, y:text.y-100},500,Phaser.Easing.Linear.None,  true, 200*(maxLength-path.length));
										textMovement.onComplete.add(function() {
											text.destroy();
											gameInfo["score"] = gameInfo["score"] + score;
										}, this);
										textMovement.onStart.add(function() {
											text.visible = true;
										}, this);
										textMovement.start();

										
										textScale.to({ x: 3, y: 3},400,Phaser.Easing.Linear.None,  true, 200*(maxLength-path.length)+100);
										textScale.start();
									});
								}
							});	
						}
					}
				}

				function findConnectingBlocks(i, j, targetVal, visited, result, path) {
					if (i < 0 || i >= rowMax) return;
					if (j < 0 || j >= colMax) return;
					if (visited[i*colMax + j] == 1) return;

					var val = fieldArray[i*colMax + j];
					visited[i*colMax + j] = 1;
					if (val == targetVal) {
						// console.log("connected: ", i, j, i*colMax +j);
						var _path = path.slice();
						_path.push(i*colMax + j);
						result[i*colMax + j] = _path;
						findConnectingBlocks(i - 1, j, targetVal, visited, result, _path);
						findConnectingBlocks(i + 1, j, targetVal, visited, result, _path);
						findConnectingBlocks(i, j - 1, targetVal, visited, result, _path);
						findConnectingBlocks(i, j + 1, targetVal, visited, result, _path);
					}
				}
				
				function moveTileWithSteps(tile,steps,callback,preCallback){
					if (preCallback) {
						preCallback(tile);
					}
					 // console.log("steps: ", steps, tile);
					 var movement = game.add.tween(tile);
					 movement.currentTile = tile;
					 // movement = movement.to({x:tile.x,y:tile.y},1,Phaser.Easing.Linear.None);
					
					 for (var i in steps) {
						 if (i==0) continue;
						 // console.log("step: ", steps[i]);
						 var step = steps[i];
						 // then we create a tween
						 movement = movement.to({x:tileSize*(toCol(step)),y:tileSize*(toRow(step))},150,Phaser.Easing.Linear.None);
					 }

					 movement.onComplete.add(function() {
						 callback(movement.currentTile);
					 }, this);
					 movement.start();
                }
				
				function isHorizontalReachable(row, colFrom, colTo) {
					var steps = Math.abs(colTo- colFrom);
					var sign = 1;
					if (colTo - colFrom < 0) {
						sign = -1;
					}
					var targetVal = fieldArray[row * colMax + colTo];
					for (var i = 0; i < steps; i ++) {
						if (fieldArray[row * colMax + colFrom + sign * i] != targetVal) {
							// console.log("?? : ", i)
							return false;
						}
					}
					// fieldArray[row * colMax + colFrom]
					return true;
				}
				
				function findConnectingBlock(targetVal, i, j) {
					for (var k=0; k<colMax;k ++) {
						var prevRowVal = fieldArray[(i-1)*colMax + k];
						if(targetVal == prevRowVal && j == k) {
							// console.log(i, j);
							for (var z=0; z<colMax; z++) {
								var pos = i*colMax + z;
								if (isHorizontalReachable(i, z, j) && fieldArray[pos] == targetVal) {
									// console.log("should move to: ", i, z);
									
									// tileSprites.forEach(function(item){
									// 	if(item.pos == pos) {
									// 		console.log("moving: " + item);
									// 		moveTile(item, pos, i*colMax + j, false);
									// 	}
									// });	
								}
							}
						}
					}
				}
				
				function test() {
					// console.log("test");
					var current = Array(colMax * rowMax).fill(0);
					for (var j=colMax - 1; j>=0; j--) {
						for (var i=rowMax - 1; i>=0; i--) {
							var visited = Array(colMax * rowMax).fill(0);
							var val = findBlocks(i, j, visited);
							if ( val >= 3) {
								current[i*colMax+j] = val;
							}
						}
					}
					
					var targetVal = -1;
					
					for (var j=colMax - 1; j>=0; j--) {
						for (var i=rowMax - 1; i>=1; i--) {
							if (current[i*colMax + j] != 0) {
								targetVal = fieldArray[i*colMax + j];
								findConnectingBlock(targetVal, i, j);
							}
						}
					}
					// console.log(current);
				}
				
				function checkBoard() {
					var out = "";
					
					
					for (var i=0; i<rowMax; i++) {
						for (var j=0; j<colMax; j++) {
						
							var visited = Array(colMax * rowMax).fill(0);
							if (fieldArray[i*colMax+j] == 0) {
								out += "0"
							} else {
								out += findBlocks(i, j, visited);
							}
							out += " ";
						}
						out += "\n";
						
					}
					// console.log(out);
				}
				
				function printBoard() {
					var out = "";
					
					
					for (var i=0; i<rowMax; i++) {
						for (var j=0; j<colMax; j++) {
						
							out += fieldArray[i*colMax + j];
							
							out += " ";
						}
						out += "\n";
						
					}
					// console.log(out);
				}
				
				function createTile(i, j, val) {
					pos = i*colMax + j;
					var tile = game.add.sprite(toCol(pos)*tileSize,(toRow(pos)-1)*tileSize,bmd);
					// creation of a custom property "pos" and assigning it the index of the newly added "2"
					tile.pos = pos;
					// at the beginning the tile is completely transparent
					tile.alpha=1;
					// creation of a text which will represent the value of the tile
					var text = game.add.text(tileSize/2,tileSize/2, val.toString(), {font:"bold 30px Arial",align:"center"});
						 // setting text anchor in the horizontal and vertical center
					text.anchor.set(0.5);
					// adding the text as a child of tile sprite
					tile.addChild(text);
					tile.inputEnabled = true;
					tile.events.onInputDown.add(() => {
						var x = toRow(tile.pos);
						var y = toCol(tile.pos);
						click(x, y);
					}, this);
					// adding tile sprites to the group
					tileSprites.add(tile);
					tile.text = text;
					// creation of a new tween for the tile sprite
					var fadeIn = game.add.tween(tile);
					// the tween will make the sprite completely opaque in 250 milliseconds
					fadeIn.to({x:tileSize*(toCol(pos)),y:tileSize*(toRow(pos))},100, Phaser.Easing.Quadratic.In);
					// tween callback
					fadeIn.onComplete.add(function(){
						// updating tile numbers. This is not necessary the 1st time, anyway
						updateNumbers();
						// now I can move
						canMove=true;
					})
					// starting the tween
					fadeIn.start();
				}
				
				function cancelConnections(endX, endY) {
					var stack = [];

					for (var i=0; i<rowMax; i++) {
						for (var j=0; j<colMax; j++) {
							var visited = Array(colMax * rowMax).fill(0);
							if (findBlocks(i, j, visited) >= 3) {
								stack.push({"x":i, "y":j});
							}
						}
					}
					
					var remove = false;
					while(stack.length > 0) {
						remove =true;
						var v = stack.pop();
						var pos = v.x * colMax + v.y;
						// console.log(v);
						
						if (v.x == endX && v.y == endY) {
							fieldArray[pos] = fieldArray[pos] + 1 ;
							updateNumbers();
						} else {
							fieldArray[pos] = 0;
							var t = tileSprites.getAt(pos);
							t.destroy();
						}
					}
					
					
					// console.log(stack);
					printBoard();
					// fall();
				}
				
				function findBlocks(i, j, visited) {
					
					// console.log(i, j);
					
					if (i < 0 || i > rowMax - 1) {
						return 0;
					}
					if (j < 0 || j > colMax - 1) {
						return 0;
					}
					
					if (visited[i * colMax + j] == 1) {
						return 0;
					} else {
						visited[i * colMax + j] = 1;
					}

					var pos = i*colMax+j;
					var val = fieldArray[pos];
					var up = 0;
					var down = 0;
					var left = 0;
					var right = 0;

					// console.log("next");
					var next = -1;
					
					next = (i - 1) * colMax + j;
					if (fieldArray[next] == val) {
						up =  findBlocks(i - 1, j, visited);
					}
					
					next = (i + 1) * colMax + j;
					if (fieldArray[next] == val) {
						down =  findBlocks(i + 1, j, visited);
					}
					
					next = i * colMax + j - 1;
					if (fieldArray[next] == val) {
						left =  findBlocks(i, j - 1, visited);
					}
					
					next = i * colMax + j + 1;
					if (fieldArray[next] == val) {
						right =  findBlocks(i, j + 1, visited);
					}
		
					return up + down + right + left + 1;
				}
				
				// GIVING A NUMBER IN A 1-DIMENSION ARRAY, RETURNS THE ROW
				function toRow(n){
					return Math.floor(n/rowMax);
				}
				
				// GIVING A NUMBER IN A 1-DIMENSION ARRAY, RETURNS THE COLUMN
				function toCol(n){
					return n%colMax;	
				}
				
				// THIS FUNCTION UPDATES THE NUMBER AND COLOR IN EACH TILE
				function updateNumbers(){
					// look how I loop through all tiles
					tileSprites.forEach(function(item){
						// retrieving the proper value to show
						var value = fieldArray[item.pos];
						// showing the value
						item.getChildAt(0).text=value;
						// tinting the tile
						item.tint=colors[value];
						var style = { font: "bold 30px Arial", fill: "#"+textColors[value], align: "center" };
						item.text.setStyle(style, true);
					});	
				}


	    		};
		</script>
    </head>
    <body>
    </body>
</html>